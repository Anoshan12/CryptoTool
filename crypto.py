# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vRv3-NjsnTOaRwkV-0rCTmhCcu3zcG-k
"""

# ==============================================================================
#  SECURE CRYPTOGRAPHY ASSISTANT (HIGH-SPEED FILE HANDLING)
#               Credits : Anoshan Yoganathan
# ==============================================================================
#
#  This version integrates Google Drive for near-instant file saving,
#  bypassing the slow browser download mechanism.
#
# ==============================================================================

# Step 1: Install necessary libraries (quietly)
!pip install cryptography python-docx PyPDF2 -q

# Step 2: Import all required modules
import os
import base64
import getpass
from google.colab import files, drive
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.exceptions import InvalidTag
import docx
import PyPDF2
from io import BytesIO

# ==============================================================================
# CORE CRYPTOGRAPHIC FUNCTIONS (Unchanged and Secure)
#              Credits : Anoshan Yoganathan
# ==============================================================================

def derive_key(password: str, salt: bytes) -> bytes:
    kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=480000)
    return kdf.derive(password.encode())

def encrypt_data(data: bytes, password: str) -> bytes:
    salt = os.urandom(16)
    key = derive_key(password, salt)
    nonce = os.urandom(12)
    aesgcm = AESGCM(key)
    encrypted_data = aesgcm.encrypt(nonce, data, None)
    return salt + nonce + encrypted_data

def decrypt_data(encrypted_blob: bytes, password: str) -> bytes:
    try:
        salt = encrypted_blob[:16]
        nonce = encrypted_blob[16:28]
        ciphertext = encrypted_blob[28:]
        key = derive_key(password, salt)
        aesgcm = AESGCM(key)
        return aesgcm.decrypt(nonce, ciphertext, None)
    except InvalidTag:
        raise ValueError("Decryption failed. The key is incorrect or the data is corrupt.")
    except Exception as e:
        raise ValueError(f"An error occurred during decryption: {e}")

# ==============================================================================
# NEW HIGH-SPEED FILE SAVING FUNCTION
#       Credits : Anoshan Yoganathan
# ==============================================================================

def save_output_file(filename: str, data: bytes):
    """
    Asks the user how they want to save the file and performs the chosen action.
    """
    print("-" * 60)
    print("How would you like to receive your file?")
    print("  1. Save to Google Drive (Recommended, very fast)")
    print("  2. Standard Browser Download (Can be slow)")
    choice = input("Enter your choice (1 or 2): ")
    print("-" * 60)

    if choice == '1':
        try:
            print("Mounting Google Drive... Please follow the authentication prompt.")
            drive.mount('/content/drive', force_remount=True)

            # Define a dedicated folder in Google Drive
            save_path_dir = '/content/drive/My Drive/Cryptography_Assistant_Files'
            os.makedirs(save_path_dir, exist_ok=True) # Create folder if it doesn't exist

            save_path_file = os.path.join(save_path_dir, filename)

            with open(save_path_file, 'wb') as f:
                f.write(data)

            print(f"\n✅ SUCCESS: File '{filename}' saved to your Google Drive.")
            print(f"   You can find it in the 'Cryptography_Assistant_Files' folder.")

        except Exception as e:
            print(f"\n❌ ERROR: Could not save to Google Drive. {e}")
            print("   Please ensure you completed the authentication steps.")

    elif choice == '2':
        print(f"Preparing '{filename}' for standard browser download...")
        print("This may take a moment. Your browser will prompt you to save the file.")
        with open(filename, 'wb') as f:
            f.write(data)
        files.download(filename)
        os.remove(filename) # Clean up the temporary file in Colab
        print(f"\n✅ SUCCESS: Download for '{filename}' initiated.")

    else:
        print("Invalid choice. File not saved.")

# ==============================================================================
# REFACTORED HANDLER FUNCTIONS (Using the new save function)
# ==============================================================================

# Text handlers are unchanged as they don't involve file downloads
def handle_encrypt_text():
    try:
        text = input("Enter the text to encrypt: ")
        password = getpass.getpass("Enter a secret key/password: ")
        if not text or not password:
            print("\nERROR: Both text and password must be provided.")
            return
        encrypted_blob = encrypt_data(text.encode('utf-8'), password)
        b64_encrypted = base64.b64encode(encrypted_blob).decode('utf-8')
        print("\n--- ENCRYPTION SUCCESSFUL ---")
        print("Copy the text below and save it in a .txt file:")
        print("-" * 60)
        print(b64_encrypted)
        print("-" * 60)
    except Exception as e:
        print(f"\nAn error occurred: {e}")

def handle_decrypt_text():
    try:
        print("\nPlease upload the encrypted .txt file:")
        uploaded = files.upload()
        if not uploaded: return
        filename = list(uploaded.keys())[0]
        os.remove(filename)
        b64_encrypted = uploaded[filename].decode('utf-8')
        encrypted_blob = base64.b64decode(b64_encrypted)
        password = getpass.getpass("Enter the secret key/password to decrypt: ")
        decrypted_text = decrypt_data(encrypted_blob, password)
        print("\n--- DECRYPTION SUCCESSFUL ---")
        print("Original Plain Text:")
        print("-" * 60)
        print(decrypted_text.decode('utf-8'))
        print("-" * 60)
    except (ValueError, TypeError) as e:
         print(f"\nDECRYPTION FAILED: {e}")
    except Exception as e:
        print(f"\nAn error occurred: {e}")

# Document handlers now use the new save_output_file function
def handle_encrypt_document():
    try:
        print("\nPlease upload the document you want to encrypt:")
        uploaded = files.upload()
        if not uploaded: return
        original_filename = list(uploaded.keys())[0]
        file_content = uploaded[original_filename]
        os.remove(original_filename)
        password = getpass.getpass("Enter a secret key/password for encryption: ")
        if not password:
            print("\nERROR: Password cannot be empty.")
            return
        data_to_encrypt = original_filename.encode('utf-8') + b':::' + file_content
        encrypted_blob = encrypt_data(data_to_encrypt, password)
        encrypted_filename = f"{os.path.splitext(original_filename)[0]}.enc"
        print(f"\n--- DOCUMENT ENCRYPTION SUCCESSFUL ---")
        # Call the new save function
        save_output_file(encrypted_filename, encrypted_blob)
    except Exception as e:
        print(f"\nAn error occurred: {e}")

def handle_decrypt_document():
    try:
        print("\nPlease upload the encrypted document (e.g., file.enc):")
        uploaded = files.upload()
        if not uploaded: return
        encrypted_filename = list(uploaded.keys())[0]
        encrypted_blob = uploaded[encrypted_filename]
        os.remove(encrypted_filename)
        password = getpass.getpass("Enter the secret key/password to decrypt: ")
        decrypted_payload = decrypt_data(encrypted_blob, password)
        separator_pos = decrypted_payload.find(b':::')
        if separator_pos == -1:
            print("\nDECRYPTION FAILED: File format incorrect or corrupt.")
            return
        original_filename = decrypted_payload[:separator_pos].decode('utf-8')
        original_content = decrypted_payload[separator_pos + 3:]
        print(f"\n--- DOCUMENT DECRYPTION SUCCESSFUL ---")
        # Call the new save function
        save_output_file(original_filename, original_content)
    except ValueError as e:
         print(f"\nDECRYPTION FAILED: {e}")
    except Exception as e:
        print(f"\nAn error occurred: {e}")

# ==============================================================================
# MAIN APPLICATION LOGIC & USER INTERFACE
# ==============================================================================
def run_assistant():
    print("="*60)
    print("      SECURE CRYPTOGRAPHY ASSISTANT (High-Speed Version)")
    print("="*60)
    print("\nThis version offers Google Drive integration for fast file handling.")
    print("-" * 60)

    while True:
        print("\nPlease select an option:")
        print("  1. Encrypt Plain Text (Instant)")
        print("  2. Decrypt Plain Text (Instant)")
        print("  3. Encrypt a Document (Save to Drive or Download)")
        print("  4. Decrypt a Document (Save to Drive or Download)")
        print("  5. Exit")
        choice = input("Enter your choice (1-5): ")

        if choice == '1': handle_encrypt_text()
        elif choice == '2': handle_decrypt_text()
        elif choice == '3': handle_encrypt_document()
        elif choice == '4': handle_decrypt_document()
        elif choice == '5':
            print("\nThank you for using the Secure Cryptography Assistant. Goodbye!")
            break
        else:
            print("\nInvalid choice. Please enter a number between 1 and 5.")

# --- Run the application ---
if __name__ == "__main__":
    run_assistant()

